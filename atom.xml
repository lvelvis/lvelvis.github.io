<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://lvelvis.github.io</id>
    <title>lvelvis</title>
    <updated>2020-06-03T06:09:15.457Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://lvelvis.github.io"/>
    <link rel="self" href="http://lvelvis.github.io/atom.xml"/>
    <subtitle>时光,浓淡相宜;人心,远近相安;这就是最好的生活</subtitle>
    <logo>http://lvelvis.github.io/images/avatar.png</logo>
    <icon>http://lvelvis.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, lvelvis</rights>
    <entry>
        <title type="html"><![CDATA[golang笔记-beego获取url请求的参数]]></title>
        <id>http://lvelvis.github.io/post/golang-bi-ji-beego-huo-qu-url-qing-qiu-de-can-shu/</id>
        <link href="http://lvelvis.github.io/post/golang-bi-ji-beego-huo-qu-url-qing-qiu-de-can-shu/">
        </link>
        <updated>2020-06-02T04:00:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="获取参数">获取参数</h1>
<p>我们经常需要获取用户传递的数据，包括Get、POST等方式的请求，beego里面会自动解析这些数据，你可以通过如下方式获取数据：</p>
<p>GetString(key string) string<br>
GetStrings(key string) []string<br>
GetInt(key string) (int64, error)<br>
GetBool(key string) (bool, error)<br>
GetFloat(key string) (float64, error)<br>
示例1：</p>
<pre><code>func (this *MainController) Post() {
    jsoninfo := &lt;strong&gt;this.GetString&lt;/strong&gt;(&quot;jsoninfo&quot;)
    if jsoninfo == &quot;&quot; {
        this.Ctx.WriteString(&quot;jsoninfo is empty&quot;)
        return
    }
}```
如果你需要的数据可能是其它类型，例如是int类型而不是int64，那么你需要这样处理：

示例2：
</code></pre>
<p>func (this *MainController) Post() {<br>
id := <strong>this.Input().Get</strong>(&quot;id&quot;)<br>
intid, err := <strong>strconv.Atoi</strong>(id)<br>
}```<br>
更多其他的request的信息，用户可以通过this.Ctx.Request获取信息。</p>
<p>关于该对象的属性和方法可参考request官方手册https://gowalker.org/net/http#Request</p>
<h1 id="直接解析到struct">直接解析到struct</h1>
<p>如果要把表单里的内容赋值到一个struct里，除了用上面的方法一个一个获取再赋值之外，<br>
beego提供了通过另外一个更便捷的方式，就是通过struct的字段名或tag与表单字段对应直接解析到struct。</p>
<p>示例3：</p>
<p>定义struct</p>
<pre><code>type user struct {
    Id    int         `form:&quot;-&quot;`
    Name  interface{} `form:&quot;&lt;strong&gt;username&lt;/strong&gt;&quot;`
    Age   int         `form:&quot;&lt;strong&gt;age&lt;/strong&gt;&quot;`
    Email string
}
</code></pre>
<p>表单</p>
<pre><code>&lt;form id=&quot;&lt;strong&gt;user&lt;/strong&gt;&quot;&gt;
    名字：&lt;input name=&quot;&lt;strong&gt;username&lt;/strong&gt;&quot; type=&quot;text&quot; /&gt;
    年龄：&lt;input name=&quot;&lt;strong&gt;age&lt;/strong&gt;&quot; type=&quot;text&quot; /&gt;
    邮箱：&lt;input name=&quot;Email&quot; type=&quot;text&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
&lt;/form&gt;
</code></pre>
<p>controller里解析</p>
<pre><code>func (this *MainController) Post() {
    u := &lt;strong&gt;user{}&lt;/strong&gt;
    if err := this.ParseForm(&lt;strong&gt;&amp;u&lt;/strong&gt;); err != nil {
        //handle error
    }
}　　
</code></pre>
<p>需要说明的是：</p>
<p>（1）structTag form的定义和renderform方法共用一个标签。</p>
<p>（2）定义struct时，字段名后如果有form这个tag，则会把form表单里的name和tag的名字一样的字段赋值给这个字段，</p>
<p>否则就会把form表单里与字段名一样的表单内容赋值给这个字段。</p>
<p>例如上面的例子中，会把表单中的username和age分别赋值给user里的Name和Age字段，而Email里的内容则会赋值给Email这个字段。</p>
<p>（3）调用Controller PraseForm这个方法的时候，传入的参数必须为一个struct的指针，否则对struct的赋值不会成功并返回xx must be a struct pointer的错误。</p>
<p>（4）如果要忽略一个字段，有两种方法，一是：字段名小写开头，二是：form标签设置为_</p>
<h1 id="获取request-body里的内容">获取Request Body里的内容</h1>
<p>在API的开发中，我们经常会用到JSON或XML来作为数据交互的格式，如何在beego中获取Request Body里的JSON或XML的数据呢？</p>
<p>首先，在配置文件里设置copyrequestbody = true</p>
<p>其次，在Controller中：</p>
<p>示例4：</p>
<pre><code>func (this *ObjectController) Post() {
    var ob models.Object
    var err error
    if err = json.Unmarshal(this.Ctx.Input.RequestBody, &amp;ob); err == nil {
        objectid := models.AddOne(ob)
        this.Data[&quot;json&quot;] = &quot;{\&quot;ObjectId\&quot;:\&quot;&quot; + objectid + &quot;\&quot;}&quot;
    } else {
        this.Data[&quot;json&quot;] = err.Error()
    }
    this.ServeJSON()
}
</code></pre>
<p></p>
<h1 id="文件上传">文件上传</h1>
<p>在beego中你可以很容易的处理文件上传，就是别忘记在你的form表单中增加“enctype=&quot;multipart/form-data”，否则你的浏览器不会传输你的上传文件。</p>
<p>文件上传之后一般是放在系统的内存里面，如果文件的size大于设置的缓存大小，那么就放在临时文件中，</p>
<p>默认的缓存内存是64M，你可以通过如下方式来调整这个缓存内存的大小。</p>
<p>beego.MaxMemory = 1&lt;&lt;22<br>
或者在配置文件中通过如下设置：</p>
<p>maxmemory = 1&lt;&lt;22<br>
Beego提供了两个很方便的方法来处理文件上传：</p>
<p>（1）GetFile(key string) (multipart.File, *multipart.FileHeader, error)</p>
<p>该方法主要用于用户读取表单中的文件名the_file，然后返回相应的信息，用户根据这些变量来处理文件上传：过滤、保存文件等。</p>
<p>（2）SaveToFile(fromfile, tofile string) error</p>
<p>该方法是在GetFile的基础上实现了快速保存的功能，fromfile是提交的时候html表单中的name。</p>
<p>示例5</p>
<p>表单：</p>
<pre><code>&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;uploadname&quot; /&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>Controller中代码：</p>
<pre><code>func (c *FormController) Post() {
    f, h, err := c.GetFile(&quot;uploadname&quot;)
    if err != nil {
        log.Fatal(&quot;getfile err &quot;, err)
    }
    defer f.Close()
    c.SaveToFile(&quot;uploadname&quot;, &quot;static/upload/&quot; + h.Filename) // 保存位置在 static/upload, 没有文件夹要先创建
     
}
</code></pre>
<h1 id="数据绑定">数据绑定</h1>
<p>支持从用户请求中直接数据bind到指定的对象。</p>
<p>示例6：</p>
<pre><code>var id int
this.Ctx.Input.Bind(&amp;id, &quot;id&quot;)  //id ==123
 
var isok bool
this.Ctx.Input.Bind(&amp;isok, &quot;isok&quot;)  //isok ==true
 
var ft float64
this.Ctx.Input.Bind(&amp;ft, &quot;ft&quot;)  //ft ==1.2
 
ol := make([]int, 0, 2)
this.Ctx.Input.Bind(&amp;ol, &quot;ol&quot;)  //ol ==[1 2]
 
ul := make([]string, 0, 2)
this.Ctx.Input.Bind(&amp;ul, &quot;ul&quot;)  //ul ==[str array]
 
user struct{Name}
this.Ctx.Input.Bind(&amp;user, &quot;user&quot;)  //user =={Name:&quot;astaxie&quot;}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[golang笔记-json数据解析：Marshal与Unmarshal]]></title>
        <id>http://lvelvis.github.io/post/golang-bi-ji-json-shu-ju-jie-xi-marshal-yu-unmarshal/</id>
        <link href="http://lvelvis.github.io/post/golang-bi-ji-json-shu-ju-jie-xi-marshal-yu-unmarshal/">
        </link>
        <updated>2020-05-28T10:15:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>Json(Javascript Object Nanotation)是一种数据交换格式，常用于前后端数据传输。任意一端将数据转换成json 字符串，另一端再将该字符串解析成相应的数据结构，如string类型，strcut对象等。</p>
<p>go语言本身为我们提供了json的工具包”encoding/json”。<br>
更多的使用方式，可以参考：https://studygolang.com/articles/6742</p>
<h1 id="实现">实现</h1>
<p>Json Marshal：将数据编码成json字符串<br>
看一个简单的例子</p>
<pre><code>type Stu struct {
    Name  string `json:&quot;name&quot;`
    Age   int
    HIgh  bool
    sex   string
    Class *Class `json:&quot;class&quot;`
}

type Class struct {
    Name  string
    Grade int
}

func main() {
    //实例化一个数据结构，用于生成json字符串
    stu := Stu{
        Name: &quot;张三&quot;,
        Age:  18,
        HIgh: true,
        sex:  &quot;男&quot;,
    }

    //指针变量
    cla := new(Class)
    cla.Name = &quot;1班&quot;
    cla.Grade = 3
    stu.Class=cla

    //Marshal失败时err!=nil
    jsonStu, err := json.Marshal(stu)
    if err != nil {
        fmt.Println(&quot;生成json字符串错误&quot;)
    }

    //jsonStu是[]byte类型，转化成string类型便于查看
    fmt.Println(string(jsonStu))
}
</code></pre>
<p>结果：</p>
<pre><code>{&quot;name&quot;:&quot;张三&quot;,&quot;Age&quot;:18,&quot;HIgh&quot;:true,&quot;class&quot;:{&quot;Name&quot;:&quot;1班&quot;,&quot;Grade&quot;:3}}
</code></pre>
<p>从结果中可以看出</p>
<p>只要是可导出成员（变量首字母大写），都可以转成json。因成员变量sex是不可导出的，故无法转成json。</p>
<p>如果变量打上了json标签，如Name旁边的 <code>json:&quot;name&quot;</code> ，那么转化成的json key就用该标签“name”，否则取变量名作为key，如“Age”，“HIgh”。</p>
<p>bool类型也是可以直接转换为json的value值。Channel， complex 以及函数不能被编码json字符串。当然，循环的数据结构也不行，它会导致marshal陷入死循环。</p>
<p>指针变量，编码时自动转换为它所指向的值，如cla变量。<br>
（当然，不传指针，Stu struct的成员Class如果换成Class struct类型，效果也是一模一样的。只不过指针更快，且能节省内存空间。）</p>
<p>最后，强调一句：json编码成字符串后就是纯粹的字符串了。</p>
<p>上面的成员变量都是已知的类型，只能接收指定的类型，比如string类型的Name只能赋值string类型的数据。<br>
但有时为了通用性，或使代码简洁，我们希望有一种类型可以接受各种类型的数据，并进行json编码。这就用到了interface{}类型。</p>
<p>前言：<br>
interface{}类型其实是个空接口，即没有方法的接口。go的每一种类型都实现了该接口。因此，任何其他类型的数据都可以赋值给interface{}类型。</p>
<pre><code>type Stu struct {
    Name  interface{} `json:&quot;name&quot;`
    Age   interface{}
    HIgh  interface{}
    sex   interface{}
    Class interface{} `json:&quot;class&quot;`
}

type Class struct {
    Name  string
    Grade int
}

func main() {
    //与前面的例子一样
    ......
}
</code></pre>
<p>结果：</p>
<pre><code>{&quot;name&quot;:&quot;张三&quot;,&quot;Age&quot;:18,&quot;HIgh&quot;:true,&quot;class&quot;:{&quot;Name&quot;:&quot;1班&quot;,&quot;Grade&quot;:3}}
</code></pre>
<p>从结果中可以看出，无论是string，int，bool，还是指针类型等，都可赋值给interface{}类型，且正常编码，效果与前面的例子一样。</p>
<p>补充：<br>
在实际项目中，编码成json串的数据结构，往往是切片类型。如下定义了一个[]StuRead类型的切片</p>
<pre><code>//正确示范

//方式1：只声明，不分配内存
var stus1 []*StuRead

//方式2：分配初始值为0的内存
stus2 := make([]*StuRead,0)

//错误示范
//new()只能实例化一个struct对象，而[]StuRead是切片，不是对象
stus := new([]StuRead)

stu1 := StuRead{成员赋值...}
stu2 := StuRead{成员赋值...}

//由方式1和2创建的切片，都能成功追加数据
//方式2最好分配0长度，append时会自动增长。反之指定初始长度，长度不够时不会自动增长，导致数据丢失
stus1 := appen(stus1,stu1,stu2)
stus2 := appen(stus2,stu1,stu2)

//成功编码
json1,_ := json.Marshal(stus1)
json2,_ := json.Marshal(stus2)
</code></pre>
<p>解码时定义对应的切片接受即可</p>
<p>Json Unmarshal：将json字符串解码到相应的数据结构<br>
我们将上面的例子进行解码</p>
<pre><code>type StuRead struct {
    Name  interface{} `json:&quot;name&quot;`
    Age   interface{}
    HIgh  interface{}
    sex   interface{}
    Class interface{} `json:&quot;class&quot;`
    Test  interface{}
}

type Class struct {
    Name  string
    Grade int
}

func main() {
    //json字符中的&quot;引号，需用\进行转义，否则编译出错
    //json字符串沿用上面的结果，但对key进行了大小的修改，并添加了sex数据
    data:=&quot;{\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;Age\&quot;:18,\&quot;high\&quot;:true,\&quot;sex\&quot;:\&quot;男\&quot;,\&quot;CLASS\&quot;:{\&quot;naME\&quot;:\&quot;1班\&quot;,\&quot;GradE\&quot;:3}}&quot;
    str:=[]byte(data)

    //1.Unmarshal的第一个参数是json字符串，第二个参数是接受json解析的数据结构。
    //第二个参数必须是指针，否则无法接收解析的数据，如stu仍为空对象StuRead{}
    //2.可以直接stu:=new(StuRead),此时的stu自身就是指针
    stu:=StuRead{}
    err:=json.Unmarshal(str,&amp;stu)

    //解析失败会报错，如json字符串格式不对，缺&quot;号，缺}等。
    if err!=nil{
        fmt.Println(err)
    }

    fmt.Println(stu)
}
</code></pre>
<p>结果：</p>
<pre><code>{张三 18 true &lt;nil&gt; map[naME:1班 GradE:3] &lt;nil&gt;}
</code></pre>
<p>总结：</p>
<p>json字符串解析时，需要一个“接收体”接受解析后的数据，且Unmarshal时接收体必须传递指针。否则解析虽不报错，但数据无法赋值到接受体中。如这里用的是StuRead{}接收。</p>
<p>解析时，接收体可自行定义。json串中的key自动在接收体中寻找匹配的项进行赋值。匹配规则是：</p>
<p>先查找与key一样的json标签，找到则赋值给该标签对应的变量(如Name)。<br>
没有json标签的，就从上往下依次查找变量名与key一样的变量，如Age。或者变量名忽略大小写后与key一样的变量。如HIgh，Class。第一个匹配的就赋值，后面就算有匹配的也忽略。<br>
(前提是该变量必需是可导出的，即首字母大写)。<br>
不可导出的变量无法被解析（如sex变量，虽然json串中有key为sex的k-v，解析后其值仍为nil,即空值）</p>
<p>当接收体中存在json串中匹配不了的项时，解析会自动忽略该项，该项仍保留原值。如变量Test，保留空值nil。</p>
<p>你一定会发现，变量Class貌似没有解析为我们期待样子。因为此时的Class是个interface{}类型的变量，而json串中key为CLASS的value是个复合结构，不是可以直接解析的简单类型数据（如“张三”，18，true等）。所以解析时，由于没有指定变量Class的具体类型，json自动将value为复合结构的数据解析为map[string]interface{}类型的项。也就是说，此时的struct Class对象与StuRead中的Class变量没有半毛钱关系，故与这次的json解析没有半毛钱关系。</p>
<p>让我们看一下这几个interface{}变量解析后的类型</p>
<pre><code>func main() {
    //与前边json解析的代码一致
    ...
    fmt.Println(stu) //打印json解析前变量类型
    err:=json.Unmarshal(str,&amp;stu)
    fmt.Println(&quot;--------------json 解析后-----------&quot;)
    ... 
    fmt.Println(stu) //打印json解析后变量类型    
}

//利用反射，打印变量类型
func printType(stu *StuRead){
    nameType:=reflect.TypeOf(stu.Name)
    ageType:=reflect.TypeOf(stu.Age)
    highType:=reflect.TypeOf(stu.HIgh)
    sexType:=reflect.TypeOf(stu.sex)
    classType:=reflect.TypeOf(stu.Class)
    testType:=reflect.TypeOf(stu.Test)

    fmt.Println(&quot;nameType:&quot;,nameType)
    fmt.Println(&quot;ageType:&quot;,ageType)
    fmt.Println(&quot;highType:&quot;,highType)
    fmt.Println(&quot;sexType:&quot;,sexType)
    fmt.Println(&quot;classType:&quot;,classType)
    fmt.Println(&quot;testType:&quot;,testType)
}
</code></pre>
<p>结果：</p>
<pre><code>nameType: &lt;nil&gt;
ageType: &lt;nil&gt;
highType: &lt;nil&gt;
sexType: &lt;nil&gt;
classType: &lt;nil&gt;
testType: &lt;nil&gt;
--------------json 解析后-----------
nameType: string
ageType: float64
highType: bool
sexType: &lt;nil&gt;
classType: map[string]interface {}
testType: &lt;nil&gt;
</code></pre>
<p>从结果中可见</p>
<p>interface{}类型变量在json解析前，打印出的类型都为nil，就是没有具体类型，这是空接口（interface{}类型）的特点。</p>
<p>json解析后，json串中value，只要是”简单数据”，都会按照默认的类型赋值，如”张三”被赋值成string类型到Name变量中，数字18对应float64，true对应bool类型。</p>
<p>“简单数据”：是指不能再进行二次json解析的数据，如”name”:”张三”只能进行一次json解析。<br>
“复合数据”：类似”CLASS\”:{\”naME\”:\”1班\”,\”GradE\”:3}这样的数据，是可进行二次甚至多次json解析的，因为它的value也是个可被解析的独立json。即第一次解析key为CLASS的value，第二次解析value中的key为naME和GradE的value</p>
<p>对于”复合数据”，如果接收体中配的项被声明为interface{}类型，go都会默认解析成map[string]interface{}类型。如果我们想直接解析到struct Class对象中，可以将接受体对应的项定义为该struct类型。如下所示：</p>
<p>type StuRead struct {<br>
...<br>
//普通struct类型<br>
Class Class <code>json:&quot;class&quot;</code><br>
//指针类型<br>
Class *Class <code>json:&quot;class&quot;</code><br>
}</p>
<p>stu打印结果</p>
<p>Class类型：{张三 18 true <nil> {1班 3} <nil>}<br>
*Class类型：{张三 18 true <nil> 0xc42008a0c0 <nil>}</p>
<p>可以看出，传递Class类型的指针时，stu中的Class变量存的是指针，我们可通过该指针直接访问所属的数据，如stu.Class.Name/stu.Class.Grade</p>
<p>Class变量解析后类型</p>
<p>classType: main.Class<br>
classType: *main.Class<br>
解析时，如果接受体中同时存在2个匹配的项，会发生什么呢？<br>
测试1</p>
<p>type StuRead struct {<br>
NAme interface{}<br>
Name  interface{}<br>
NAMe interface{}    <code>json:&quot;name&quot;</code><br>
}<br>
结果1:</p>
<pre><code>//当存在匹配的json标签时，其对应的项被赋值。
//切记：匹配的标签可以没有，但有时最好只有一个哦
{&lt;nil&gt; &lt;nil&gt; 张三}
</code></pre>
<p>测试2</p>
<p>type StuRead struct {<br>
NAme interface{}<br>
Name  interface{}<br>
NAMe interface{}    <code>json:&quot;name&quot;</code><br>
NamE interface{}    <code>json:&quot;name&quot;</code><br>
}<br>
结果2</p>
<pre><code>//当匹配的json标签有多个时，标签对应的项都不会被赋值。
//忽略标签项，从上往下寻找第一个没有标签且匹配的项赋值
{张三 &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;}
</code></pre>
<p>测试3</p>
<p>type StuRead struct {<br>
NAme interface{}<br>
Name  interface{}<br>
}<br>
结果3</p>
<pre><code>//没有json标签时，从上往下，第一个匹配的项会被赋值哦
{张三 &lt;nil&gt;}
</code></pre>
<p>测试4</p>
<pre><code>type StuRead struct {
    NAMe interface{}    `json:&quot;name&quot;`
    NamE interface{}    `json:&quot;name&quot;`
}
</code></pre>
<p>结果4</p>
<pre><code>//当相同的json标签有多个，且没有不带标签的匹配项时，报错了哦
# command-line-arguments
src/test/b.go:48: stu.Name undefined (type *StuRead has no field or method Name, but does have NAMe)
</code></pre>
<p>可见，与前边说过的匹配规则是一致的。</p>
<p>如果不想指定Class变量为具体的类型，仍想保留interface{}类型，但又希望该变量可以解析到struct Class对象中，这时候该怎么办呢？</p>
<p>这种需求是很可能存在的，例如笔者我就碰到了</p>
<p>办法还是有的，我们可以将该变量定义为json.RawMessage类型</p>
<pre><code>type StuRead struct {
    Name  interface{}
    Age   interface{}
    HIgh  interface{}
    Class json.RawMessage `json:&quot;class&quot;` //注意这里
}

type Class struct {
    Name  string
    Grade int
}

func main() {
    data:=&quot;{\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;Age\&quot;:18,\&quot;high\&quot;:true,\&quot;sex\&quot;:\&quot;男\&quot;,\&quot;CLASS\&quot;:{\&quot;naME\&quot;:\&quot;1班\&quot;,\&quot;GradE\&quot;:3}}&quot;
    str:=[]byte(data)
    stu:=StuRead{}
    _:=json.Unmarshal(str,&amp;stu)

    //注意这里：二次解析！
    cla:=new(Class)
    json.Unmarshal(stu.Class,cla)

    fmt.Println(&quot;stu:&quot;,stu)
    fmt.Println(&quot;string(stu.Class):&quot;,string(stu.Class))
    fmt.Println(&quot;class:&quot;,cla)
    printType(&amp;stu) //函数实现前面例子有
}
</code></pre>
<p>结果</p>
<pre><code>stu: {张三 18 true [123 34 110 97 77 69 34 58 34 49 231 143 173 34 44 34 71 114 97 100 69 34 58 51 125]}
string(stu.Class): {&quot;naME&quot;:&quot;1班&quot;,&quot;GradE&quot;:3}
class: &amp;{1班 3}
nameType: string
ageType: float64
highType: bool
classType: json.RawMessage
</code></pre>
<p>从结果中可见</p>
<p>接收体中，被声明为json.RawMessage类型的变量在json解析时，变量值仍保留json的原值，即未被自动解析为map[string]interface{}类型。如变量Class解析后的值为：{“naME”:”1班”,”GradE”:3}</p>
<p>从打印的类型也可以看出，在第一次json解析时，变量Class的类型是json.RawMessage。此时，我们可以对该变量进行二次json解析，因为其值仍是个独立且可解析的完整json串。我们只需再定义一个新的接受体即可，如json.Unmarshal(stu.Class,cla)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[golang笔记-数组、切片、map]]></title>
        <id>http://lvelvis.github.io/post/golang-bi-ji-shu-zu-qie-pian-map/</id>
        <link href="http://lvelvis.github.io/post/golang-bi-ji-shu-zu-qie-pian-map/">
        </link>
        <updated>2020-05-26T05:29:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数组">数组</h1>
<p>数组的长度一旦定义了就不能动态增长，并且存储的数据类型必须相同。</p>
<h2 id="创建方法">创建方法：</h2>
<p>var 数组名 [长度]数据类型<br>
例如：</p>
<pre><code>package main
import &quot;fmt&quot;
 
func main(){
    var test [5]int //定义数组名字test，长度为5，数据类型为int的数组
    test[0] = 1    //赋值
    test[1] = 2   
    test[2] = 3
    test[3] = 4
    fmt.Println(test) 
    fmt.Println(test[2])
    fmt.Println(test[1:3]) //输出1到3的数组
    fmt.Println(test[0:]) //0到结尾
    fmt.Println(test[:3])  //0到3
 
}
</code></pre>
<pre><code>##结果##
[1 2 3 4 0]
3
[2 3]
[1 2 3 4 0]
[1 2 3]
</code></pre>
<h2 id="数组的四种初始化方式">数组的四种初始化方式</h2>
<p>例如：</p>
<pre><code>var s1 [3]int = [3]int{1,2,3}
fmt.Println(&quot;s1&quot;,s1)
var s2 [4]int = [...]int{5,6,7,8} //[...]是固定写法
fmt.Println(&quot;s2&quot;,s2)
var s3 = [2]int{9,10} //第一种的简化
fmt.Println(&quot;s3&quot;,s3)
var s4 = [...]int{3:43,1:41,0:40,2:42} //类似键值对
fmt.Println(&quot;s4&quot;,s4)
var s5 = new([5]int)
s5[4] =12
fmt.Println(&quot;s5&quot;,s5)
</code></pre>
<pre><code>##结果##
s1 [1 2 3]
s2 [5 6 7 8]
s3 [9 10]
s4 [40 41 42 43]
s5 [0 0 0 0 5]
</code></pre>
<h2 id="数组的遍历">数组的遍历</h2>
<p>例如：</p>
<pre><code>var s4 = [...]int{3:43,1:41,0:40,2:42} //类似键值对
fmt.Println(&quot;s4&quot;,s4)
     
for index,value := range s4{
fmt.Println(index,value)
}
 
#结果##
0 40
1 41
2 42
3 43
</code></pre>
<pre><code>var s4 = [...]int{3:43,1:41,0:40,2:42} //类似键值对
for i := 0;i &lt;len(s4);i++{
fmt.Println(i,s4[i])
}
 
#结果##
0 40
1 41
2 42
3 43
</code></pre>
<h1 id="slice切片">slice切片</h1>
<p>1、切片是数组的引用(切片是数组的一部分)<br>
2、切片的使用类似数组，如遍历<br>
3、切片的长度是可变的</p>
<h2 id="创建语法">创建语法</h2>
<p>var 切片名 []类型<br>
如：</p>
<pre><code>var qiepian []int
</code></pre>
<h2 id="切片示例">切片示例:</h2>
<pre><code>###例子一&lt;br&gt;var suzhu [4]int = [...]int{5,6,7,8}
slice := suzhu[1:4] //1到4的值，不包含4
fmt.Println(suzhu)
fmt.Println(slice)
fmt.Println(&quot;切片的容量&quot;,cap(slice))
 
##结果
[5 6 7 8]
[6 7 8]
切片的容量 3&lt;br&gt;&lt;br&gt;
###例子二、使用make创建切片
var slice []int = make([]int,4,10) //类型，大小(长度),容量（可选），容量必须大于长度
slice[0] = 10
slice[1] = 11
fmt.Println(slice)
 
##结果##
[10 11 0 0]
 
 
###例子三
var slice []int = []int {2,4,6}
fmt.Println(slice)
 
##结果##
2 4 6
</code></pre>
<h2 id="切片的append追加">切片的append追加</h2>
<p>例如：</p>
<pre><code>var slice []int = []int {2,4,6}
fmt.Println(slice)
//使用append直接追加切片内容（类似python list的append）
slice = append(slice,8,10)
fmt.Println(slice)
slice = append(slice,slice...) //追加切片，...是固定写法
fmt.Println(slice)
 
###结果###
[2 4 6]
[2 4 6 8 10]
[2 4 6 8 10 2 4 6 8 10]
</code></pre>
<h2 id="切片的copy操作">切片的copy操作</h2>
<p>使用copy内置函数<br>
例如:</p>
<pre><code>var slice []int = []int {2,4,6}
fmt.Println(slice)
var slice2 []int = make([]int,5)
fmt.Println(slice2)
copy(slice2,slice) //将slice复制给slice2
fmt.Println(slice)
fmt.Println(slice2)
 
##结果##
[2 4 6]
[0 0 0 0 0]
[2 4 6]
[2 4 6 0 0]
</code></pre>
<h2 id="使用切片改变字符串的内容">使用切片改变字符串的内容</h2>
<pre><code>var str string = &quot;hello&quot;
fmt.Println(str)
arr := []byte(str)
arr[1] = 'a' //转成字符串
arr1 := []rune(str) //中文转换
arr1[0] = '狗'
fmt.Println(arr)
str = string(arr)
fmt.Println(str)
str = string(arr1)
fmt.Println(str)
 
##结果##
hello
[104 97 108 108 111]
hello
狗hello
</code></pre>
<h1 id="map">map</h1>
<p>map是key-value数据结构(类似python的dict)<br>
map是无序存储的</p>
<p>创建map语法<br>
var map 变量名 map[keytype]valuetype</p>
<p>如：</p>
<pre><code>var m1 map[string]string
var m2 map[string]int
var m3 map[int]string
var m4 map[string]map[string]string
```　　

使用例子：
</code></pre>
<p>package main<br>
import &quot;fmt&quot;</p>
<p>func main(){<br>
var m1 map[string]string<br>
//在使用map前,需要先make，make的作用技术给map分配数据空间<br>
m1 = make(map[string]string)<br>
m2 := map[string]string{  //使用方式二<br>
&quot;a1&quot; : &quot;q1&quot;,<br>
&quot;a2&quot; : &quot;a2&quot;,<br>
}<br>
m1[&quot;s1&quot;] = &quot;亚索&quot;<br>
m1[&quot;s2&quot;] = &quot;盖伦&quot;<br>
fmt.Println(m1)<br>
fmt.Println(m1[&quot;s1&quot;])<br>
fmt.Println(m2)<br>
}</p>
<p>###结果###<br>
map[s1:亚索 s2:盖伦]<br>
亚索<br>
map[a1:q1 a2:a2]</p>
<pre><code>
 

map的增删改查
增、改
map[key] = value //没有就增加，存在就修改

删
delete(map,key)

查
map[key]   //对应的value，和python的dict一样</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[k8s hpa弹性扩容配置]]></title>
        <id>http://lvelvis.github.io/post/k8s-hpa-dan-xing-kuo-rong-pei-zhi/</id>
        <link href="http://lvelvis.github.io/post/k8s-hpa-dan-xing-kuo-rong-pei-zhi/">
        </link>
        <updated>2020-05-19T05:24:13.000Z</updated>
        <content type="html"><![CDATA[<pre><code>HPA全称Horizontal Pod Autoscaling，是K8s实现pod自动水平扩容缩容的特性，这个特性使整个kubernetes集群马上高大上起来了。
要使用HPA也不是这么简单的，HPA api分v1、v2beta1、v2bate2三种，v1只支持通过CPU衡量扩缩容，v2bate1加入针对内存作为度量，v2bate2可以用customer metrics例如网络等，所以v2bate1开始才比较实用。
</code></pre>
<p>要使用HPA必须要开启以下两个特性：</p>
<p>Aggregation Layer 聚合层，通过与核心的apiserver分离，实现自定义的扩展功能<br>
metrics-server 数据收集，能够收集pod、node等实时运行指标（cpu、内存），给k8s集群使用，例如kubectl top命令、HPA<br>
比较老的版本使用heapster</p>
<h1 id="aggregation-layer">Aggregation Layer</h1>
<p>要打开Aggregation Layer，需要配置一下apiserver，增加相关认证证书。认证流程是client发起请求到apiserver，apiserver与aggergated apiserver建立tls安全链接，把请求proxy到aggergated apiserver，继续进行–requestheader-*参数的相关认证。</p>
<p>认证流程<br>
<img src="http://lvelvis.github.io/post-images/1589865988979.png" alt="" loading="lazy"></p>
<p>需要生成aggregate使用的证书，参考cfssl生成证书方法，proxy-client-cert-file的CN需要与requestheader-allowed-names匹配。<br>
在apiserver增加如下启动参数</p>
<pre><code>--requestheader-client-ca-file=/etc/kubernetes/pki/agg-ca.pem
--proxy-client-cert-file=/etc/kubernetes/pki/aggregate.pem
--proxy-client-key-file=/etc/kubernetes/pki/aggregate-key.pem
--requestheader-allowed-names=aggregator
--requestheader-extra-headers-prefix=X-Remote-Extra-
--requestheader-group-headers=X-Remote-Group
--requestheader-username-headers=X-Remote-User
#如果kube-proxy没有在Master上面运行，还需要配置
--enable-aggregator-routing=true
</code></pre>
<h1 id="metrics-server">metrics server</h1>
<p>从k8s 1.8开始，集群的资源使用情况都通过metrics api收集，例如容器CPU、内存。这些指标可用于kuberctl top或者k8s的HPA等特性。<br>
metrice server可以在github找到并部署</p>
<pre><code>git clone https://github.com/kubernetes-incubator/metrics-server
cd metrics-server
kubectl create -f deploy/1.8+/
</code></pre>
<pre><code>注1：metrics-server默认使用node的主机名，但是coredns里面没有物理机主机名的解析，一种是部署的时候添加一个参数： –kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP,第二种是使用dnsmasq构建一个上游的dns服务
注2：kubelet 的10250端口使用的是https协议，连接需要验证tls证书。可以在metrics server启动命令添加参数–kubelet-insecure-tls不验证客户端证书
注3：yaml文件中的image地址k8s.gcr.io/metrics-server-amd64:v0.3.3 需要梯子，需要改成中国可以访问的image地址，可以使用aliyun的。这里使用hub.docker.com里的google镜像地址 image: mirrorgooglecontainers/metrics-server-amd64:v0.3.3
</code></pre>
<p>成功运行kubectl top命令</p>
<pre><code>ubuntu@k8s-dev-m1:~/k8sssl/agglayer$ kubectl top nodes
NAME                   CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%   
k8s-dev-node2          103m         5%      2696Mi                 72%       
k8s-dev-node3.bxr.cn   115m      2%     5312Mi                  67%  
k8s-dev-node4          57m          2%       2634Mi                  70%     
k8s-dev-node5          148m         7%       2443Mi                  65%
</code></pre>
<h1 id="hpa">HPA</h1>
<pre><code>有了metrics就可以开始使用HPA特性了。hpa有几个特点
deploy或者rs等需要设置resources才能使用hpa
如果我们创建一个HPA controller，它会每隔15s（可以通过–horizontal-pod-autoscaler-sync-period修改）检测一次hpa定义的资源与实际资源使用情况，如果达到阀值就会调整pod数量。
HPA设置的阀值不是绝对的，允许设置一个浮动范围，–horizontal-pod-autoscaler-tolerance默认是0.1
pod调整算法 desiredReplicas = ceil[currentReplicas * ( currentMetricValue / desiredMetricValue )]
scale有一个窗口期，期间每次变化会记录下来，选择最优的调整建议再进行scale，这样可以保证资源平滑变动，通过–horizontal-pod-autoscaler-downscale-stabilization设定，默认5分钟。
通过hpa调整新增的pod不会马上ready，这时候收集的metrics就不准，为了减少影响，hpa一开始不会收集新pod的metrics。通过–horizontal-pod-autoscaler-initial-readiness-delay（默认30s）和 –horizontal-pod-autoscaler-cpu-initialization-period（默认为 5 分钟）调整
</code></pre>
<p><img src="http://lvelvis.github.io/post-images/1589866316410.svg" alt="" loading="lazy"><br>
示例hpa.yml:</p>
<pre><code>apiVersion: autoscaling/v2beta2
kind: HorizontalPodAutoscaler
metadata:
  name: hpa-test
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: podinfo
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 75
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization 
        averageUtilization: 160
</code></pre>
<p>上面的示例包括cpu和memory指标，averageUtilization这个百分比是根据deployment的resources.requests计算的。例如有deployment限制requests是512Mi，replicas是2，实际pod1用了612Mi，pod2用了598Mi，计算公式是 (612+598)/2/512 = 118%</p>
<p>查看hpa的情况，targets第一个是memory，第二个是cpu指标，REPLICAS是根据计算后的当前pod数</p>
<pre><code>ubuntu@k8s-m1:~/k8s/hpa$ kubectl get hpa
NAME       REFERENCE            TARGETS             MINPODS   MAXPODS   REPLICAS   AGE
hpa-test   Deployment/podinfo   120%/160%, 6%/75%   2         4         3          97m
</code></pre>
<p>官方示例还包括packets-per-second、requests-per-second这些指标，需要进一步验证</p>
<pre><code>apiVersion: autoscaling/v2beta1
kind: HorizontalPodAutoscaler
metadata:
  name: php-apache
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: php-apache
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: AverageUtilization
        averageUtilization: 50
  - type: Pods
    pods:
      metric:
        name: packets-per-second
      targetAverageValue: 1k
  - type: Object
    object:
      metric:
        name: requests-per-second
      describedObject:
        apiVersion: networking.k8s.io/v1beta1
        kind: Ingress
        name: main-route
      target:
        kind: Value
        value: 10k
status:
  observedGeneration: 1
  lastScaleTime: &lt;some-time&gt;
  currentReplicas: 1
  desiredReplicas: 1
  currentMetrics:
  - type: Resource
    resource:
      name: cpu
    current:
      averageUtilization: 0
      averageValue: 0
  - type: Object
    object:
      metric:
        name: requests-per-second
      describedObject:
        apiVersion: networking.k8s.io/v1beta1
        kind: Ingress
        name: main-route
      current:
        value: 10k

</code></pre>
<p><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#create-horizontal-pod-autoscaler">官方hpa参数</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[beego静态文件加载路径修改]]></title>
        <id>http://lvelvis.github.io/post/beego-jing-tai-wen-jian-jia-zai-lu-jing-xiu-gai/</id>
        <link href="http://lvelvis.github.io/post/beego-jing-tai-wen-jian-jia-zai-lu-jing-xiu-gai/">
        </link>
        <updated>2020-05-11T04:49:08.000Z</updated>
        <content type="html"><![CDATA[<p>Go 语言内部其实已经提供了 http.ServeFile，通过这个函数可以实现静态文件的服务。</p>
<p>beego 针对这个功能进行了一层封装，通过下面的方式进行静态文件注册：</p>
<pre><code>beego.SetStaticPath(&quot;/static&quot;,&quot;public&quot;)
</code></pre>
<p>第一个参数是路径，url 路径信息<br>
第二个参数是静态文件目录（相对应用所在的目录）<br>
beego 支持多个目录的静态文件注册，用户可以注册如下的静态文件目录：</p>
<pre><code>beego.SetStaticPath(&quot;/images&quot;,&quot;images&quot;)
beego.SetStaticPath(&quot;/css&quot;,&quot;css&quot;)
beego.SetStaticPath(&quot;/js&quot;,&quot;js&quot;)
```　　

设置了如上的静态目录之后，用户访问 /images/login/login.png，那么就会访问应用对应的目录下面的 images/login/login.png 文件。

如果是访问 /static/img/logo.png，那么就访问 public/img/logo.png文件。

默认情况下 beego 会判断目录下文件是否存在，不存在直接返回 404 页面，如果请求的是 index.html，那么由于 http.ServeFile 默认是会跳转的，不提供该页面的显示。

因此 beego 可以设置 beego.BConfig.WebConfig.DirectoryIndex=true 这样来使得显示 index.html 页面。而且开启该功能之后，用户访问目录就会显示该目录下所有的文件列表。</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用户空间挂载 CEPH 文件系统]]></title>
        <id>http://lvelvis.github.io/post/yong-hu-kong-jian-gua-zai-ceph-wen-jian-xi-tong/</id>
        <link href="http://lvelvis.github.io/post/yong-hu-kong-jian-gua-zai-ceph-wen-jian-xi-tong/">
        </link>
        <updated>2020-05-08T06:03:36.000Z</updated>
        <content type="html"><![CDATA[<p>Ceph v0.55 及后续版本默认开启了 cephx 认证。从用户空间（ FUSE ）挂载一 Ceph 文件系统前，确保客户端主机有一份 Ceph 配置副本、和具备 Ceph 元数据服务器能力的密钥环。</p>
<p>1、 在客户端主机上，把监视器主机上的 Ceph 配置文件拷贝到 /etc/ceph/ 目录下</p>
<pre><code>sudo mkdir -p /etc/ceph
sudo scp {user}@{server-machine}:/etc/ceph/ceph.conf /etc/ceph/ceph.conf
</code></pre>
<p>2、 在客户端主机上，把监视器主机上的 Ceph 密钥环拷贝到 /etc/ceph 目录下</p>
<pre><code>sudo scp {user}@{server-machine}:/etc/ceph/ceph.keyring /etc/ceph/ceph.keyring
</code></pre>
<p>3、 确保客户端机器上的 Ceph 配置文件和密钥环都有合适的权限位，如 chmod 644 。<br>
cephx 如何配置请参考 CEPHX 配置参考。<br>
要把 Ceph 文件系统挂载为用户空间文件系统，可以用 ceph-fuse 命令，例如：</p>
<pre><code>sudo mkdir /home/usernname/cephfs
sudo ceph-fuse -m 192.168.0.1:6789 /home/username/cephfs
</code></pre>
<p>详情见 <a href="http://docs.ceph.org.cn/man/8/ceph-fuse/">ceph-fuse</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux如何导入自定义证书]]></title>
        <id>http://lvelvis.github.io/post/linux-ru-he-dao-ru-zi-ding-yi-zheng-shu/</id>
        <link href="http://lvelvis.github.io/post/linux-ru-he-dao-ru-zi-ding-yi-zheng-shu/">
        </link>
        <updated>2020-05-06T08:33:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<pre><code>curl https://192.168.0.200:8443
提示curl: (60) Peer's Certificate issuer is not recognized.
curl: (60) Peer's Certificate issuer is not recognized.
More details here: http://curl.haxx.se/docs/sslcerts.html

curl performs SSL certificate verification by default, using a &quot;bundle&quot;
 of Certificate Authority (CA) public keys (CA certs). If the default
 bundle file isn't adequate, you can specify an alternate file
 using the --cacert option.
If this HTTPS server uses a certificate signed by a CA represented in
 the bundle, the certificate verification probably failed due to a
 problem with the certificate (it might be expired, or the name might
 not match the domain name in the URL).
If you'd like to turn off curl's verification of the certificate, use
 the -k (or --insecure) option.
</code></pre>
<h1 id="mac-os-x">Mac OS X</h1>
<h2 id="添加证书">添加证书：</h2>
<pre><code>sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ~/new-root-certificate.crt
</code></pre>
<h2 id="移除证书">移除证书：</h2>
<pre><code>sudo security delete-certificate -c &quot;&lt;name of existing certificate&gt;&quot;
</code></pre>
<h1 id="windows">Windows</h1>
<h2 id="添加证书-2">添加证书：</h2>
<pre><code>certutil -addstore -f &quot;ROOT&quot; new-root-certificate.crt
</code></pre>
<h2 id="移除证书-2">移除证书：</h2>
<pre><code>certutil -delstore &quot;ROOT&quot; serial-number-hex
</code></pre>
<h1 id="linux-ubuntu-debian">Linux (Ubuntu, Debian)</h1>
<h2 id="添加证书-3">添加证书：</h2>
<pre><code>复制 CA 文件到目录： /usr/local/share/ca-certificates/
执行:
sudo cp foo.crt /usr/local/share/ca-certificates/foo.crt
</code></pre>
<h2 id="更新-ca-证书库">更新 CA 证书库:</h2>
<pre><code>sudo update-ca-certificates
</code></pre>
<h2 id="移除证书-3">移除证书：</h2>
<pre><code>Remove your CA.

Update the CA store:

sudo update-ca-certificates --fresh

Restart Kerio Connect to reload the certificates in the 32-bit versions or Debian 7.
</code></pre>
<h1 id="linux-centos-6">Linux (CentOs 6)</h1>
<h2 id="添加证书-4">添加证书：</h2>
<p>// root-ca.crt 为ca证书</p>
<pre><code>安装 ca-certificates package:

yum install ca-certificates

启用dynamic CA configuration feature:

update-ca-trust force-enable

Add it as a new file to /etc/pki/ca-trust/source/anchors/:
cp root-ca.crt /etc/pki/ca-trust/source/anchors/

执行:

update-ca-trust extract

Restart Kerio Connect to reload the certificates in the 32-bit version.
</code></pre>
<h1 id="linux-centos-5">Linux (CentOs 5)</h1>
<h2 id="添加证书-5">添加证书：</h2>
<pre><code>Append your trusted certificate to file /etc/pki/tls/certs/ca-bundle.crt

cat foo.crt &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt
</code></pre>
<h1 id="测试访问">测试访问</h1>
<pre><code> curl -v &quot;https:/gitlab.test.com/micro-lib/server?go-get=1&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[istio-客户端源地址如何显示]]></title>
        <id>http://lvelvis.github.io/post/istio-ke-hu-duan-yuan-di-zhi-ru-he-xian-shi/</id>
        <link href="http://lvelvis.github.io/post/istio-ke-hu-duan-yuan-di-zhi-ru-he-xian-shi/">
        </link>
        <updated>2020-04-30T07:32:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前提">前提</h3>
<p>由于istio部署到IDC、非云环境无法获取客户端真实IP地址，web应用无法使用该组件，早期版本的istio做了很多测试，最终无法实现获取remote client address；</p>
<h3 id="环境">环境</h3>
<p>kubernetes版本：k8s-1.16.9<br>
istio版本：1.5</p>
<h3 id="方法">方法</h3>
<pre><code>kubectl -n istio-system edit  deployments. istio-pilot
添加如下：
       env:
       - name: PILOT_SIDECAR_USE_REMOTE_ADDRESS
          value: &quot;true&quot;
</code></pre>
<p>以下是github相应的issue<br>
<img src="http://lvelvis.github.io/post-images/1588232244321.png" alt="" loading="lazy"></p>
<h3 id="其他测试">其他测试</h3>
<p>istio-1.5版本回归单体，各个组件优化了很多，后期测试http链接与tcp链接应用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8S通过helm 部署 ELK 7.3]]></title>
        <id>http://lvelvis.github.io/post/k8s-tong-guo-helm-bu-shu-elk-73/</id>
        <link href="http://lvelvis.github.io/post/k8s-tong-guo-helm-bu-shu-elk-73/">
        </link>
        <updated>2020-04-30T07:12:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前提">前提：</h1>
<p>在kubernetes集群中部署elk组件，es集群部署3个节点，kibana部署一个，容器数据持久化需要storageclass</p>
<p>依赖：<br>
Helm<br>
Persistent Volumes</p>
<h1 id="准备配置">准备配置</h1>
<p>由于repo在线安装太慢，建议下载char本地修改参数后安装</p>
<pre><code>git clone https://github.com/elastic/helm-charts.git
</code></pre>
<h1 id="部署-elk">部署 ELK</h1>
<h2 id="创建elk命名空间">创建elk命名空间</h2>
<pre><code>#cat elk-ns.yml
apiVersion: v1
kind: Namespace
metadata:
  name: elk
</code></pre>
<h2 id="部署elasticsearch">部署elasticsearch</h2>
<p>cd helm-charts/elasticsearch</p>
<p>helm install --namespace=elk  --name=elasticsearch .</p>
<h2 id="部署-kibana">部署 Kibana</h2>
<p>cd helm-charts/kibana</p>
<p>helm install --namespace=elk --name=kibana .<br>
通过 kubectl get deploy 和 pod 了解部署状态；</p>
<h1 id="小知识">小知识</h1>
<p>Kibana 直接通过 K8S 内部 DNS 域名 访问 ES。</p>
<p>查看容器内的配置</p>
<pre><code>kubectl  exec kibana-kibana-7cbc5db55c-6qct7 -c kibana -- cat /usr/share/kibana/config/kibana.yml

# Default Kibana configuration for docker target
server.name: kibana
server.host: &quot;0&quot;
elasticsearch.hosts: [ &quot;http://elasticsearch:9200&quot; ]
xpack.monitoring.ui.container.elasticsearch.enabled: true
</code></pre>
<h1 id="kibana-添加-ingress">Kibana 添加 Ingress</h1>
<p>通过 Ingress 添加访问入口</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: kibana
  namespace: default
spec:
  rules:
  - host: &lt;YourDomain&gt;  ## 访问 Kibana 的域名 
    http:
      paths:
      - backend:
          serviceName: kibana-kibana
          servicePort: 5601
        path: /
 status:
  loadBalancer:
    ingress:
    - ip: &lt;YourLoadBalancerIP&gt;  ## LB 的 IP
</code></pre>
<h1 id="访问测试">访问测试</h1>
<p>访问域名，即可打开 Kibana 7.3 版本；</p>
<figure data-type="image" tabindex="1"><img src="http://lvelvis.github.io/post-images/1588231324831.jpg" alt="" loading="lazy"></figure>
<p>查看集群的运行状态</p>
<figure data-type="image" tabindex="2"><img src="http://lvelvis.github.io/post-images/1588231313286.jpg" alt="" loading="lazy"></figure>
<p>也可以通过命令行查看</p>
<pre><code>~$ curl  -s &lt;YourESHost&gt;/_cluster/health | jq .
{
  &quot;cluster_name&quot;: &quot;elasticsearch&quot;,
  &quot;status&quot;: &quot;yellow&quot;,
  &quot;timed_out&quot;: false,
  &quot;number_of_nodes&quot;: 3,
  &quot;number_of_data_nodes&quot;: 3,
  &quot;active_primary_shards&quot;: 19,
  &quot;active_shards&quot;: 35,
  &quot;relocating_shards&quot;: 0,
  &quot;initializing_shards&quot;: 0,
  &quot;unassigned_shards&quot;: 3,
  &quot;delayed_unassigned_shards&quot;: 0,
  &quot;number_of_pending_tasks&quot;: 0,
  &quot;number_of_in_flight_fetch&quot;: 0,
  &quot;task_max_waiting_in_queue_millis&quot;: 0,
  &quot;active_shards_percent_as_number&quot;: 92.10526315789474
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[kubesphere安装使用体验]]></title>
        <id>http://lvelvis.github.io/post/kubesphere-an-zhuang-shi-yong-ti-yan/</id>
        <link href="http://lvelvis.github.io/post/kubesphere-an-zhuang-shi-yong-ti-yan/">
        </link>
        <updated>2020-04-29T09:33:05.000Z</updated>
        <content type="html"><![CDATA[<p>最近又出来个kubesphere的工具用来管理k8s，今天特意来安装体验下；<br>
github地址：https://github.com/pixiake/ks-installer</p>
<p>官方使用文档：https://kubesphere.io/docs/advanced-v2.0/zh-CN/installation/all-in-one/</p>
<p>先放上安装效果图，UI界面还是很清爽的：<br>
<img src="http://lvelvis.github.io/post-images/1588152934567.png" alt="" loading="lazy"></p>
<h3 id="当前环境">当前环境：</h3>
<pre><code>k8s集群已经安装完成，用kubesphere管理现有的k8s集群；

k8s版本为1.14  

系统为centos7.6

kubesphere使用要求：

kubernetes version &gt; 1.13.0

helm version &gt; 2.10.0

a default storage class must be in kubernetes cluster
</code></pre>
<p>安装完成后默认用户名密码：</p>
<p>用户名：admin</p>
<p>密码：P@88w0rd</p>
<h3 id="开始安装">开始安装</h3>
<p>安装步骤大概记录：</p>
<pre><code>kubectl create ns kubesphere-system
kubectl create ns kubesphere-monitoring-system

#访问etcd用到的secret
kubectl -n kubesphere-monitoring-system create secret generic kube-etcd-client-certs  --from-file=etcd-client-ca.crt=ca.pem  --from-file=etcd-client.crt=etcd-key.pem  --from-file=etcd-client.key=etcd.pem

#管理k8s用到的secret

kubectl -n kubesphere-system create secret generic kubesphere-ca  --from-file=ca.crt=ca.pem --from-file=ca.key=ca-key.pem

#clone好github项目，执行下面的这条命令

cd deploy
kubectl apply -f kubesphere-installer.yaml
</code></pre>
<p>执行完上面的命令，可以通过下面的命令，查看安装过程日志</p>
<pre><code>kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l job-name=kubesphere-installer -o jsonpath='{.items[0].metadata.name}') -f
</code></pre>
<p>查看安装结果，STATUS跟下面保持一致才说明安装成功</p>
<pre><code>[root@ks-allinone deploy]# kubectl get pods -n kubesphere-system
NAME                                     READY   STATUS      RESTARTS   AGE
ks-account-6db466d8dc-srrwj              1/1     Running     0          149m
ks-apigateway-7d77cb9495-jzmg6           1/1     Running     0          170m
ks-apiserver-f8469fd47-b58rm             1/1     Running     0          166m
ks-console-54c849bdc9-dfkbf              1/1     Running     0          168m
ks-console-54c849bdc9-z2d5q              1/1     Running     0          168m
ks-controller-manager-569456b4cd-gngm5   1/1     Running     0          170m
ks-docs-6bbdcc9bfb-6jldz                 1/1     Running     0          3h7m
kubesphere-installer-7ph6l               0/1     Completed   1          3h11m
openldap-5c986c5bff-rzqwv                1/1     Running     0          3h25m
redis-76dc4db5dd-lv6kg                   1/1     Running     0          149m
</code></pre>
<h3 id="安装过程出现的错误">安装过程出现的错误</h3>
<p>1.在安装的时提示metrics-server已经安装，导致安装中断；</p>
<p>解析办法：在kubesphere-installer.yaml的configMap增加配置：metrics_server_enable: False（默认是没有的）</p>
<pre><code>apiVersion: v1
data:
  ks-config.yaml: |
    kube_apiserver_host: 10.10.5.208:6443
    etcd_tls_enable: True
    etcd_endpoint_ips: 10.10.5.169,10.10.5.183,10.10.5.184
    disableMultiLogin: True
    elk_prefix: logstash
    metrics_server_enable: False
  #  local_registry: 192.168.1.2:5000
kind: ConfigMap
metadata:
  name: kubesphere-config
  namespace: kubesphere-system
</code></pre>
<p>增加Ingress配置：</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: kubesphere
  namespace: kubesphere-system
  annotations:
    #kubernetes.io/ingress.class: traefik
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: ks.staplescn.com
    http:
      paths:
      - path:
        backend:
          serviceName: ks-console
          servicePort: 80
</code></pre>
<p>访问界面：<br>
<img src="http://lvelvis.github.io/post-images/1588153130667.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>